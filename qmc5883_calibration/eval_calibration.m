%% Import data from text file.
% Script for importing data from the following text file:
%
%    C:\Users\Clemens\Documents\Arduino\FollowMe\qmc5883_calibration\output_2018-02-26_16-25-07.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2018/02/26 16:29:59

%% Initialize variables.
filename = 'C:\Users\Clemens\Documents\Arduino\FollowMe\qmc5883_calibration\output_2018-02-26_16-36-15.csv';
delimiter = ',';
startRow = 2;

%% Read columns of data as text:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%s%s%s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines' ,startRow-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric text to numbers.
% Replace non-numeric text with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = mat2cell(dataArray{col}, ones(length(dataArray{col}), 1));
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3,4]
    % Converts text in the input cell array to numbers. Replaced non-numeric
    % text with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1)
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData(row), regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if numbers.contains(',')
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(numbers, thousandsRegExp, 'once'))
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric text to numbers.
            if ~invalidThousandsSeparator
                numbers = textscan(char(strrep(numbers, ',', '')), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch
            raw{row, col} = rawData{row};
        end
    end
end


%% Create output variable
data = table;
data.x = cell2mat(raw(:, 1));
data.y = cell2mat(raw(:, 2));
data.z = cell2mat(raw(:, 3));
data.azimuth = cell2mat(raw(:, 4))/10;

%% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp;


%% center
cal =table;
cal.x = data.x - (min(data.x)+max(data.x))/2;
cal.y = data.y - (min(data.y)+max(data.y))/2;
cal.z = data.z - (min(data.z)+max(data.z))/2;
figure
scatter3(cal.x, cal.y, cal.z);

%% scale

if(max(cal.x) > max(cal.y))
   cal.y2 = cal.y *max(cal.x)/max(cal.y);
   cal.x2 = cal.x;
else
    cal.x2 = cal.x *max(cal.y)/max(cal.x);
    cal.y2 = cal.y;
end

%% azimuth simple

cal.azimuth1 = atan2(cal.x, cal.y)*180/pi;
cal.azimuth1 = cal.azimuth1+ (cal.azimuth1 < 0)*360;

%% azimuth simple scale
cal.azimuth2 = atan2(cal.x2, cal.y2)*180/pi;
cal.azimuth2 = cal.azimuth2+ (cal.azimuth2 < 0)*360;

figure
plot(cal.x,cal.y);
hold on
plot(cal.x2, cal.y2);
figure
plot(cal.azimuth1)
hold on
plot(cal.azimuth2)
%% azimuth angle between two vectors
[~,master_index] = max(cal.z);
master = [cal.x(master_index),cal.y(master_index),cal.z(master_index)]
compass = [cal.x, cal.y, cal.z];

s = size(compass,1);
azimuth = zeros(s,1);
azimuth90 = zeros(s,1);
test = zeros(s,1);

for i=1:s
    test(i) = dot(master,compass(i,:)) / ( norm(master)*norm(compass(i,:) ));
    azimuth(i) = acos(dot(master,compass(i,:)) / ( norm(master)*norm(compass(i,:) )));
    azimuth90(i) = acos(dot([-master(2),master(1),0],compass(i,:)) / ( norm([-master(2),master(1),0])*norm(compass(i,:) )));
end

figure
hold on
plot3([0,master(1)],[0,master(2)],[0,master(3)])
plot3([0,-master(2)],[0,master(1)],[0,0])
plot3(cal.x, cal.y, cal.z)


azimuth = azimuth *180/pi;
azimuth90 = azimuth90 *180/pi;
azimuth = azimuth .*(azimuth90 >= 90) + azimuth .*(azimuth90 < 90).* -1;

azimuth = cal.azimuth1(1)-azimuth(1) + azimuth;
azimuth = azimuth- (azimuth > 360)*360;

%azimuth90 = azimuth90+ (azimuth90 < 0)*360;

figure
hold on
plot(data.azimuth);
plot(cal.azimuth1);
plot(azimuth);
legend("QMC_38865_lib", "skaliert", "kippung um z berücksichtigt");
%plot(azimuth90);
%plot(azimuth+azimuth90);

%% fft

L=40;
bitrate=5;
tone1 = azimuth
figure;
plot(tone1);
spectrum = fft(tone1);
P2 = abs(spectrum/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);
f = bitrate*(0:(L/2))/L;
figure;
plot(f,P1) 

